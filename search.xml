<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue3特性总结</title>
      <link href="/2023/03/07/vue3-te-xing/"/>
      <url>/2023/03/07/vue3-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Vue3简介"><a href="#一、Vue3简介" class="headerlink" title="一、Vue3简介"></a>一、Vue3简介</h1><h2 id="Vue3带来了什么？"><a href="#Vue3带来了什么？" class="headerlink" title="Vue3带来了什么？"></a>Vue3带来了什么？</h2><p>（1）性能的提升；</p><p>（2）源码的升级；</p><p>使用Proxy代替defineProperty实现响应式；</p><p>重写虚拟DOM的实现和Tree-Shaking</p><p>（3）拥抱TypeScript</p><p>（4）新的特性</p><p>1.Composition API（组合API） ,抛弃传统optionsAPI</p><p>2.新的内置组件</p><p>3.其他改变</p><h1 id="二、创建Vue3工程"><a href="#二、创建Vue3工程" class="headerlink" title="二、创建Vue3工程"></a>二、创建Vue3工程</h1><h2 id="1、使用vue-cli创建"><a href="#1、使用vue-cli创建" class="headerlink" title="1、使用vue-cli创建"></a>1、使用vue-cli创建</h2><p>先安装@vue&#x2F;cli : npm install -g @vue&#x2F;cli</p><p>创建：vue create vue_test</p><p>运行：npm run serve</p><h2 id="2、使用vite创建"><a href="#2、使用vite创建" class="headerlink" title="2、使用vite创建"></a>2、使用vite创建</h2><blockquote><p>手动搭建vite环境：</p><ol><li><p>yarn init -y</p></li><li><p>yarn add vite -D</p></li><li><p>yarn add vue</p></li><li><p>在pcakage.json中配置scripts;</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"vite --open"</span><span class="token punctuation">,</span>     <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"vite build"</span><span class="token punctuation">,</span>     <span class="token property">"preview"</span><span class="token operator">:</span> <span class="token string">"vite preview"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></blockquote><p>vite是新一代前端构建工具；</p><p>优势：无需打包操作，可快速的冷启动；轻量快速的热重载；真正的按需编译；</p><p>步骤：</p><p>创建工程：npm init vite-app <project-name></p><p>安装依赖：npm install …</p><p>运行：npm run dev</p><p>自动创建项目： <code>yarn create vue</code> or <code>npm init vue@latest</code></p><h2 id="3-分析Vue3的工程结构"><a href="#3-分析Vue3的工程结构" class="headerlink" title="3. 分析Vue3的工程结构"></a>3. 分析Vue3的工程结构</h2><p>在main.js中引入的不再是Vue构造函数，引入的是一个名为createApp的工厂函数：</p><p>import { createApp } from ‘vue’</p><p>创建实例对象-app（类似于Vue2中的vm，但app比vm更“轻”：</p><p>createApp(App).mount(‘#app’)</p><blockquote><p>代码分析：</p><p>App.vue是一个根组件</p><p>——createApp(app)将根组件关联到应用上，会返回一个应用的实例</p><p>——app.mount(“#app”) 将应用挂载到页面上</p><ol><li>会返回一个根组件的实例，组件的实例通常命名为vm</li><li>组件实例是一个Proxy对象(代理对象)</li><li>组件就是一个普通的js对象</li><li>如果使用箭头函数，则无法通过this来访问组件实例</li><li>使用vue时，尽量不使用箭头函数</li><li>data会返回一个对象作为返回值，vue会对该对象进行代理，从而将其转换为响应式数据，响应式数据可以直接通过组件实例访问</li><li>直接向组件实例中添加的属性不会被vue所代理，不是响应式数据，修改后页面不会发生变化</li></ol></blockquote><h1 id="三、常用Composition-API"><a href="#三、常用Composition-API" class="headerlink" title="三、常用Composition API"></a>三、常用Composition API</h1><h2 id="1、初识setup"><a href="#1、初识setup" class="headerlink" title="1、初识setup"></a>1、初识setup</h2><p>1、setup是Vue3中一个新的配置项，值为一个函数；</p><p>2、组件中所要用到的数据、方法等，均要配置在setup中；</p><p>3、定义模板的方式有三种:</p><ol><li>在组件中通过template属性去指定</li><li>直接在网页的根元素中指定</li><li>组件中通过render函数直接渲染</li></ol><blockquote><p>注意：</p><ul><li><p>template是模板，它决定了组件最终的样子</p></li><li><p>如果在组件中定义template，则会优先使用template作为模板，同时根元素里的所有内容都会被其内容替代</p></li><li><p>如果在组件中没有定义template，则会使用根元素的innerHTML作为模板使用</p></li></ul></blockquote><p>3、<strong>setup的两种返回值：</strong></p><p>（1）：若返回一个对象，则对象中的属性、方法，均可以在模板中直接使用；</p><p>（2）：若返回一个渲染函数：则可以自定义渲染内容；</p><p><strong>setup的两个注意点：</strong></p><p>1、setup执行时机，在<strong>beforeCreate之前执行一次</strong>，this是undefined；</p><p>2、setup的参数：</p><p>（1）：props：指为对象，包含组件外部传递过来，且组件内部声明接收了的属性。</p><p>（2）：context：上下文对象</p><p>attrs：值为对象，包含组件外部传递过来，但没有在props配置中声明的属性，相当于this.$attrs；</p><p>slots：收到的插槽内容，相当于this.$slots;</p><p>emit:分发自定义事件的函数，相当于this.$emit。</p><h2 id="2、ref函数"><a href="#2、ref函数" class="headerlink" title="2、ref函数"></a>2、ref函数</h2><p>1、作用：定义一个响应式数据</p><p>2、语法：const xxx&#x3D;ref(initValue)</p><p>创建一个包含响应式数据的引用对象（reference对象，简称ref对象）；</p><p>js中操作数据：xxx.value;</p><p>模块中读取数据不需要value，直接；</p><p>3、备注</p><p>接收的数据可以是基本类型也可以是对象类型；</p><p>基本类型的数据响应式依然靠Object.defineProperty()的get和set完成的；</p><p>对象类型的数据：内部求助了Vue3中的一个新函数—reactive函数；</p><h2 id="3、reactive函数"><a href="#3、reactive函数" class="headerlink" title="3、reactive函数"></a>3、reactive函数</h2><p>作用：定义一个对象类型的响应式数据（基本类型用ref）；</p><p>语法：const 代理对象&#x3D;reactive(被代理对象）接收一个<strong>对象（或数组），</strong>返回一个代理对象（proxy对象）；</p><p>setup(){</p><pre><code>let name=ref(&quot;张三&quot;)let age=ref(18)let job=reactive(&#123;  type:&quot;前端工程师&quot;,  salary:10000&#125;)let hobby=reactive([&#39;唱歌&#39;,&#39;跳舞&#39;,&#39;游戏&#39;])function sayHello()&#123;  alert(name+&#39;,&#39;+age)&#125;function changeInfo()&#123;  name.value=&quot;李四&quot;  age.value=20  job.type=&quot;后端工程师&quot;  job.salary=20000  hobby[0]=&#39;学习&#39;  console.log(name,age,job);&#125;//返回一个对象return &#123;  name,  age,  job,  sayHello,  changeInfo,  hobby&#125;</code></pre><p>  }</p><p>}</p><h2 id="4、reactive和ref对比"><a href="#4、reactive和ref对比" class="headerlink" title="4、reactive和ref对比"></a>4、reactive和ref对比</h2><p>1、从定义数据角度对比：</p><p>ref用来定义：基本数据类型；</p><p>reactive用来定义：对象（或数组）类型数据；</p><p>备注：ref也可以用来定义对象或数组类型数据，它内部会自动通过reactive转为代理对象；</p><p>2、从原理角度对比：</p><p>ref通过Object.defineProperty()的get和set来实现响应式；</p><p>reactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据。</p><p>3、从使用角度对比：</p><p>ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value；</p><p>reactive定义的数据：操作数据与读取数据均不需要.value；</p><h2 id="5、Vue3中的响应式原理"><a href="#5、Vue3中的响应式原理" class="headerlink" title="5、Vue3中的响应式原理"></a>5、Vue3中的响应式原理</h2><p>实现原理：</p><p>通过Proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等；</p><p>通过Reflect（反射）：对被代理对象的属性进行操作；</p><p> &#x2F;&#x2F;模拟vue3中的响应式原理</p><pre><code>    let person=&#123;        name:&#39;张三&#39;,        age:18    &#125;    const p=new Proxy(person,&#123;        //有人读取p的某个属性时调用        get(target,propName)&#123;            console.log(`读取了p身上的$&#123;propName&#125;属性`);            return target[propName]        &#125;,        //有人修改p的某个属性，或给p追加某个属性时调用        set(target,propName,value)&#123;            console.log(`修改了p身上的$&#123;propName&#125;属性`);            target[propName]=value        &#125;,        //有人删除p1的某个属性时调用        deleteProperty(target,propName)&#123;            console.log(`删除p身上的$&#123;propName&#125;属性`);            return delete target[propName]        &#125;    &#125;)</code></pre><h2 id="6、Vue3中的计算属性和监视"><a href="#6、Vue3中的计算属性和监视" class="headerlink" title="6、Vue3中的计算属性和监视"></a>6、Vue3中的计算属性和监视</h2><p>1、computed函数</p><blockquote><p>methods与computed区别：</p><ol><li>计算属性只会在其依赖的数据发生变化时才会重新执行——会对数据进行缓存</li><li>methods只要数据改变(页面重新渲染)总是会执行</li></ol><p>计算属性中尽量只读数据，不要产生副作用的代码</p></blockquote><p>写法：</p><p>首先，先导入computed：import {computed} from ‘vue’</p><p>&#x2F;&#x2F;计算属性简写形式（没有考虑计算属性被修改的情况）</p><pre><code>    person.fullName=computed(()=&gt;&#123;        return person.firstName+&#39;-&#39;+person.lastName    &#125;)</code></pre><p>&#x2F;&#x2F;计算属性完整版写法</p><pre><code>    person.fullName=computed(&#123;        get()&#123;            return person.firstName+&#39;-&#39;+person.lastName        &#125;,        set(value)&#123;            const nameArr=value.split(&#39;-&#39;)            person.firstName=nameArr[0]            person.lastName=nameArr[1]        &#125;    &#125;)</code></pre><p>2、watch函数</p><p>watch函数可以传递三个参数，第一个参数是监视的属性，第二个参数是执行的回调函数，第三个参数是配置；</p><p>&#x2F;&#x2F;情况一：监视ref所定义的一个数据</p><pre><code>    watch(sum,(newValue,oldValue)=&gt;&#123;        console.log(&#39;sum变了&#39;,newValue,oldValue);    &#125;,&#123;immediate:true&#125;)    //情况二：监视ref所定义的多个响应数据    watch([sum,msg],(newValue,oldValue)=&gt;&#123;        console.log(&#39;sum变了huomsg变了&#39;,newValue,oldValue);    &#125;)    //情况三：监视reactive所定义的一个响应式数据 的全部属性    // 注意：1、无法正确的获取oldValue 2、强制开启了深度监视（deep配置无效）    watch(person,()=&gt;&#123;        console.log(&#39;person变化了&#39;);    &#125;)    //情况四：监视reactive所定义的一个响应式数据中的某个属性    watch(()=&gt;person.age,(newValue,oldValue)=&gt;&#123;        console.log(&#39;age变化了&#39;,newValue,oldValue);    &#125;)    //情况五：监视reactive所定义的一个响应式数据中的某些属性    watch([()=&gt;person.age,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;        console.log(&#39;age,name变化了&#39;,newValue,oldValue);    &#125;)</code></pre><p>注意特殊情况 当监视reactive所定义的对象中的某个属性，这个时候deep配置有效</p><p>3、watchEffect函数</p><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调用到哪个属性，就监视哪个属性。</p><p>watchEffect有点像computed：</p><p>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值；</p><p>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值；</p><p>&#x2F;&#x2F;监视的回调中用到哪个属性就监视哪个属性</p><pre><code>    watchEffect(()=&gt;&#123;        const x1=sum.value        const x2=person.job.j1.salary        console.log(&#39;watchEffect所指定的回调函数执行了&#39;,x1,x2);    &#125;)</code></pre><h2 id="7、Vue3中的生命周期"><a href="#7、Vue3中的生命周期" class="headerlink" title="7、Vue3中的生命周期"></a>7、Vue3中的生命周期</h2><p>vue3中可以继续使用vue2中的生命周期钩子，但有两个被更名：</p><p><strong>beforeDestroy改名为beforeUnmount；</strong></p><p><strong>destroyed改名为unmounted</strong>；</p><p>vue3中也提供了CompositionAPI形式的生命周期钩子，与vue2中钩子对应关系如下：</p><p><strong>beforeCreate&#x3D;&gt;setup（）</strong></p><p><strong>created&#x3D;&gt;setup()</strong></p><p>意思是setup相当于beforeCreate和created，所以不用往setup中放；</p><p><strong>beforeMount&#x3D;&gt;onBeforeMount</strong></p><p><strong>mounted&#x3D;&gt;onMounted</strong></p><p><strong>beforeUpdate&#x3D;&gt;onBeforeUpdate</strong></p><p><strong>updated&#x3D;&gt;onUpdated</strong></p><p><strong>beforeUnmount&#x3D;&gt;onBeforeUnmount</strong></p><p><strong>unmounted&#x3D;&gt;onUnmounted</strong></p><h2 id="8、Vue3中的自定义的hook函数"><a href="#8、Vue3中的自定义的hook函数" class="headerlink" title="8、Vue3中的自定义的hook函数"></a>8、Vue3中的自定义的hook函数</h2><p>定义：本质是一个函数，把setup函数中使用的Composition API进行了封装；</p><p>类似于Vue2中的mixin；</p><p>自定义hook的优势，复用代码，让setup中的逻辑更清楚易懂；</p><h2 id="9、Vue3中的toRef"><a href="#9、Vue3中的toRef" class="headerlink" title="9、Vue3中的toRef"></a>9、Vue3中的toRef</h2><p>作用：创建一个ref对象，其value值指向另一个对象中的某个属性；</p><p>语法：</p><p> return{<br>            name:toRef(person,’name’),</p><pre><code>        age:toRef(person,&#39;age&#39;),        salary:toRef(person.job.j1,&#39;salary&#39;)    &#125;</code></pre><p>应用：要将响应式对象中的某个属性单独提供给外部使用时；</p><p>扩展：toRefs和toRef功能一致，但可以批量创建多个ref对象，语法：toRefs（person)。</p><h1 id="四、其他Composition-API"><a href="#四、其他Composition-API" class="headerlink" title="四、其他Composition API"></a>四、其他Composition API</h1><h2 id="1、shallowReactive和shallowRef"><a href="#1、shallowReactive和shallowRef" class="headerlink" title="1、shallowReactive和shallowRef"></a>1、shallowReactive和shallowRef</h2><p>shallowReactive只处理对象最外层属性的响应式（浅响应式）；</p><p>shallowRef只处理基本数据类型的响应式，不进行对象式响应式的处理；</p><p>如果有一个对象数据，结构比较深，但变化时只是外层属性变化，用shallowReactive；</p><p>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换，用shallowRef；</p><h2 id="2、readOnly和shallowReadonly"><a href="#2、readOnly和shallowReadonly" class="headerlink" title="2、readOnly和shallowReadonly"></a>2、readOnly和shallowReadonly</h2><p>readOnly：让一个响应式数据变为只读的（深只读）；</p><p>shallowReadonly：让一个响应式数据变为只读的（浅只读）；</p><p>应用场景：不希望数据被修改时；</p><p>shallowReadonly(person)</p><h2 id="3、toRaw和markRaw"><a href="#3、toRaw和markRaw" class="headerlink" title="3、toRaw和markRaw"></a>3、toRaw和markRaw</h2><p>toRaw：</p><p>作用：将一个由reactive生成的<strong>响应式对象</strong>转为普通对象；</p><p>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新；</p><p>markRaw：</p><p>作用：标记一个对象，使其永远不会再成为响应式对象；</p><p>应用场景：</p><p>（1）、有些值不应被设置为响应式的，例如复杂的第三方类库；</p><p>（2）、当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</p><h2 id="4、customRef"><a href="#4、customRef" class="headerlink" title="4、customRef"></a>4、customRef</h2><p>作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显式控制；</p><p>function myRef(value){<br>      let timer</p><pre><code>  return customRef((track,trigger)=&gt;&#123;   return&#123;      get()&#123;        console.log(&#39;有人读取数据了&#39;);        track()//通知vue追踪value的变化        return value      &#125;,      set(newValue)&#123;        console.log(&#39;有人修改数据了&#39;);        clearTimeout(timer)        timer=setTimeout(()=&gt;&#123;          value=newValue          trigger()//重新解析模板        &#125;,2000)      &#125;   &#125;  &#125;)&#125;</code></pre><h2 id="5、provide和inject"><a href="#5、provide和inject" class="headerlink" title="5、provide和inject"></a>5、provide和inject</h2><p>作用：实现祖与后代间组件间通信；(父子之间用Props)</p><p>套路：父组件有一个provide选项来提供数据，后代组件有一个inject选项来开始使用这些数据。</p><p>1、祖组件：</p><pre><code> setup()&#123;    let car=reactive(&#123;      name:&#39;car&#39;,     price:188888&#125;)provide(&#39;car&#39;,car)//给自己的后代组件传递数据return &#123; ...toRefs(car)&#125;</code></pre><p>  }</p><p>2、后代组件</p><pre><code> setup()&#123;   let car=inject(&#39;car&#39;)   return&#123;        car    &#125;&#125;</code></pre><h2 id="6、响应式数据的判断"><a href="#6、响应式数据的判断" class="headerlink" title="6、响应式数据的判断"></a>6、响应式数据的判断</h2><p>1、isRef：检查一个值是否为一个ref对象；</p><p>2、isReactive：检查一个对象是否由reactive创建的响应式代理；</p><p>3、isReadonly：检查一个对象是否由readonly创建的响应式代理；</p><p>4、isProxy：检查一个对象是否由reactive或readonly方法创建的代理；</p><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1、Fragment"><a href="#1、Fragment" class="headerlink" title="1、Fragment"></a>1、Fragment</h2><p>在vue2中，组件必须有一个根标签；</p><p>在vue3中，组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中；</p><p>好处是减少标签层级，减小内存占用。</p><h2 id="2、Teleport"><a href="#2、Teleport" class="headerlink" title="2、Teleport"></a>2、Teleport</h2><p>Teleport是一种能够将我们的组件html结构移动到指定位置的技术。</p><pre><code> &lt;teleport to=&#39;移动位置&#39; &gt;      &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;          &lt;div class=&quot;dialog&quot;&gt;            danchuang&lt;br&gt;            &lt;button @click=&quot;isShow=false&quot;&gt;关闭弹窗&lt;/button&gt;          &lt;/div&gt;      &lt;/div&gt;  &lt;/teleport&gt;</code></pre><h2 id="3、Suspense"><a href="#3、Suspense" class="headerlink" title="3、Suspense"></a>3、Suspense</h2><p>等待异步组件时渲染一些额外的内容，让应用有更好的用户体验；</p><p>使用步骤：</p><p>1、异步引入组件；</p><p>2、使用suspense包裹组件，并配置好default和fallback；</p><h1 id="六、响应式原理——代理"><a href="#六、响应式原理——代理" class="headerlink" title="六、响应式原理——代理"></a>六、响应式原理——代理</h1><ul><li><p>创建一个对象：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"啊啊啊"</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">&#125;</span>obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"bbb"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li><p>如果直接修改对象的属性，那么仅仅就说修改了属性，没有去做其他事情，这种操作只会影响对象自身，不会导致元素的重新渲染</p></li><li><p>希望在修改一个属性的同时，可以进行一些其他的操作，比如触发元素重新渲染——Vue3中使用<strong>代理模式来</strong>完成对象的改造</p></li></ul></blockquote></li><li><p>为对象创建一个代理</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//来为对象创建一个代理</span><span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//get用来指定读取数据时的行为，它的返回值是最终读取到的值</span>    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 返回值之前做一些其他操作。。。</span>        <span class="token comment">//在vue中，data()返回的对象会被vue所代理</span>        <span class="token comment">//vue代理后，当我们通过代理去读取属性时，返回值之前，它会先做一个跟踪的操作</span>        <span class="token comment">// 当我们通过代理去修改属性时，修改后，会通知之前所有用到该值的进行更新</span>        <span class="token comment">//track() 追踪谁用了我这个属性</span>                <span class="token comment">/*        三个参数：        target: 被代理的对象 obj        prop: 读取的属性 proxy.name : name        receiver: 代理对象 proxy        */</span>                <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">//set会在通过代理修改对象时调用</span>    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> value        <span class="token comment">//trigger() 触发所有使用了该值的位置进行更新</span>                <span class="token comment">//修改值之后做一些操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//handler用来指定代理的行为</span><span class="token comment">//创建代理</span><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token comment">//修改代理属性</span>proxy<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">28</span> <span class="token comment">//obj.age = 28</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>代理对象</p><blockquote><ul><li>设置代理时不会对原对象产生影响</li><li>在原始对象操作属性时不会更改DOM</li><li>vm.$data指向实际代理对象，通过vm可以直接访问到$data中的属性,vm.$data.name &#x3D; vm.name</li><li>可以通过vm.$data动态的向组件添加响应式数据，但是不建议这么做</li></ul></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/07/hello-world/"/>
      <url>/2023/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
